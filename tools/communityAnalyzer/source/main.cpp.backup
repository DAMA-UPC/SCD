

#include <fstream>
#include <types.h>
#include <graph.h>
#include <iostream>
#include <math.h>
#include <map>
#include <set>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <globals.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include <queue>

using namespace sfcd;

struct Statistics;
struct Community;
struct Subgraph;
Graph *	graph;
std::vector<std::set<uint32_t>*> * sets;
Statistics * statistics;
Subgraph * subgraphs;
uint32_t median;

uint32_t * nodeNumCommunities;
std::set<uint32_t>  * nodeCommunities;
uint32_t * histogramComSize;
uint32_t * histogramNodeCommunities;
double64_t alpha;


uint64_t timeModularity;
uint64_t timeConductance;
uint64_t timeFlakeODF;
uint64_t timeExpansion;
uint64_t timeCutRatio;
uint64_t timeDiameters;
uint64_t timeBridges;
uint64_t timeFOMD;
uint64_t timeInternalDensity;
uint64_t timeTPR;
uint64_t timeWCC;



bool compare_nodes(uint32_t first, uint32_t second)
{
	return nodeNumCommunities[first] > nodeNumCommunities[second];
}


struct Subgraph
{
	uint32_t size;
	std::set<uint32_t> * adjacencies;
	Subgraph()
	{
		size = 0;
		adjacencies = NULL;
	}

	~Subgraph()
	{
		if(adjacencies != NULL)
		{
			delete [] adjacencies;
			adjacencies = NULL;
		}
	}

};


struct Statistics
{
	double64_t wcc;
	double64_t triangleRatio;		// trianglesIn / trianglesTotals.
	double64_t triangleDensity;		// trianglesIn / possibles trianglesIn.
	double64_t communityEdgeRatio;		// per cada node, nombre de comunitats a les que esta connectat entre el nombre d'arestes externes.
	double64_t avgEdgeDensity; 	// per cada node, percentatge de nodes de la comunitat que son veins seus.
	double64_t avgInverseEdgeCut;	// per cada node, percentatge de veins que formen part de la comunitat.
	double64_t modularity;			// modularitat de la comunitat.
	double64_t conductance;			// conductan√ßa de la comunitat.
	double64_t flakeODF;			// el Flake-ODF.
	double64_t expansion;			// l'expansion.
	double64_t cutRatio;			// the Cut Ratio.
	double64_t fomd;			// fraction over median degree.
	double64_t internalDensity;		// the internal density of edges.
	double64_t tpr;				// triangle participation ratio.
	uint32_t diameter;			// el diametre de la comunitat.
	uint32_t bridges;			// nombre d'arestes pont dins la comunitat.
	double64_t bridgesRatio;		// nombre d'arestes pont dins la comunitat.
	uint32_t size;				// la mida de la comunitat.
	uint32_t connectedComponents;		// el nombre de components connexes.

	Statistics()
	{
		wcc = 0.0f;
		triangleRatio = 0.0f;
		communityEdgeRatio = 0.0f;
		avgEdgeDensity = 0.0f;
		avgInverseEdgeCut = 0.0f;
		modularity = 0.0f;
		conductance = 0.0f;
		flakeODF = 0.0f;
		expansion = 0.0f;
		cutRatio = 0.0f;
		fomd = 0.0f;
		internalDensity = 0.0f;
		tpr = 0.0f;
		diameter = 0;
		bridges = 0;
		size = 0;
		connectedComponents = 0;
	}

};

void ComputeInternalDensity(uint32_t i)
{

	statistics[i].internalDensity = 0.0f;
	std::set<uint32_t> * set = (*sets)[i];
	uint32_t inDegree = 0;

	for(std::set<uint32_t>::iterator it = set->begin();it!=set->end();it++)
	{
		uint32_t node = *it;
		uint32_t degree = graph->GetDegree(node);
		Adjacency * adjacencies = graph->GetNeighbors(node);
		for(uint32_t j = 0; j < degree; j++)
		{
			if(set->find(adjacencies[j].nodeId) != set->end())
			{
				inDegree++;
			}
		}

	}
	statistics[i].internalDensity = inDegree / (double64_t)(set->size()*(set->size()-1));
}

void ComputeFOMD(uint32_t i)
{
		statistics[i].fomd = 0.0f;
		std::set<uint32_t> * set = (*sets)[i];
		uint32_t numNodesOverMedian = 0;
		for(std::set<uint32_t>::iterator it = set->begin();it!=set->end();it++)
		{
			uint32_t node = *it;
			uint32_t degree = graph->GetDegree(node);
			uint32_t inDegree = 0;
			Adjacency * adjacencies = graph->GetNeighbors(node);
			for(uint32_t j = 0; j < degree; j++)
			{
			
				if(set->find(adjacencies[j].nodeId) != set->end())
				{
					inDegree++;

				}
			}

			if(inDegree > median)
			{
				numNodesOverMedian++;
			}	
		}
		statistics[i].fomd = numNodesOverMedian / (double64_t)set->size();
}

void ComputeCutRatio(uint32_t i)
{

	statistics[i].cutRatio= 0.0f;
	std::set<uint32_t> * set = (*sets)[i];
	uint32_t outDegree = 0;
	for(std::set<uint32_t>::iterator it = set->begin();it!=set->end();it++)
	{
		uint32_t node = *it;
		uint32_t degree = graph->GetDegree(node);
		Adjacency * adjacencies = graph->GetNeighbors(node);
		for(uint32_t j = 0; j < degree; j++)
		{
			if(set->find(adjacencies[j].nodeId) == set->end())
			{
				outDegree++;
			}
		}

	}
	statistics[i].cutRatio = outDegree / (double64_t)(set->size()*(graph->GetNumNodes()-set->size()));

}


void ComputeExpansion(uint32_t i)
{

		statistics[i].expansion= 0.0f;
		std::set<uint32_t> * set = (*sets)[i];
		uint32_t outDegree = 0;
		for(std::set<uint32_t>::iterator it = set->begin();it!=set->end();it++)
		{
			uint32_t node = *it;
			uint32_t degree = graph->GetDegree(node);
			Adjacency * adjacencies = graph->GetNeighbors(node);
			for(uint32_t j = 0; j < degree; j++)
			{
				if(set->find(adjacencies[j].nodeId) == set->end())
				{
					outDegree++;
				}
			}

		}
		statistics[i].expansion = outDegree / (double64_t)set->size();

}



void ComputeFlakeODF(uint32_t i)
{

		statistics[i].flakeODF = 0.0f;
		std::set<uint32_t> * set = (*sets)[i];
		uint32_t numNodesWithHighOutDegree = 0;
		for(std::set<uint32_t>::iterator it = set->begin();it!=set->end();it++)
		{
			uint32_t node = *it;
			uint32_t degree = graph->GetDegree(node);
			uint32_t outDegree = 0;
			Adjacency * adjacencies = graph->GetNeighbors(node);
			for(uint32_t j = 0; j < degree; j++)
			{
			
				if(set->find(adjacencies[j].nodeId) == set->end())
				{
					outDegree++;

				}
			}

			if(outDegree*2 > degree)
			{
				numNodesWithHighOutDegree++;
			}	
		}
		statistics[i].flakeODF = numNodesWithHighOutDegree / (double64_t)set->size();

}

void ComputeTriangles(uint32_t nodeId1, uint32_t nodeId2,std::set<uint32_t> * set,uint32_t & totalTriangles,uint32_t & internalTriangles)
{

	bool trianglePossible = true;
	if(set->find(nodeId1)==set->end() || set->find(nodeId2)==set->end())
	{
		trianglePossible=false;
	}	


	totalTriangles = 0;
	internalTriangles = 0;
	uint32_t i = 0;
	uint32_t j = 0; 
	
	Adjacency * adjacencies1 = graph->GetNeighbors(nodeId1);	
	Adjacency * adjacencies2 = graph->GetNeighbors(nodeId2);	

	while(i < graph->GetDegree(nodeId1) && j < graph->GetDegree(nodeId2))
	{
			uint32_t node1 = adjacencies1[i].nodeId; 
			uint32_t node2 = adjacencies2[j].nodeId; 
			//uint32_t edgeId = adjacencies2[j].edgeId; 

			if(node1 == node2  )
			{
				totalTriangles++;
				i++;
				j++;
				if(set->find(node1)!=set->end() && trianglePossible)
				{
					internalTriangles++;
				}

			}
			else
			{
				if(adjacencies1[i].nodeId < adjacencies2[j].nodeId)
				{
					i++;
				} 
				else
				{
					j++;
				}
			}
	}
}

void ComputeTPR(uint32_t i) {

		statistics[i].tpr = 0.0f;
		std::set<uint32_t> * set = (*sets)[i];
		uint32_t numNodesWithTriangle = 0;
		for(std::set<uint32_t>::iterator it = set->begin();it!=set->end();it++)
		{
			uint32_t node = *it;
			uint32_t degree = graph->GetDegree(node);
			uint32_t outDegree = 0;
			uint32_t numTriangles = 0;
			Adjacency * adjacencies = graph->GetNeighbors(node);
			for(uint32_t j = 0; j < degree; j++)
			{
				if(set->find(adjacencies[j].nodeId) != set->end())
				{
					uint32_t totalTriangles;
					uint32_t internalTriangles;
					ComputeTriangles(node, adjacencies[j].nodeId, set, totalTriangles, internalTriangles );
					if( internalTriangles > 0 ) {
						numTriangles++;
					}

				}
			}
			if( numTriangles > 0 ) {
				numNodesWithTriangle++;
			}
		}
		statistics[i].tpr = numNodesWithTriangle/ (double64_t)set->size();
}

void ComputeWCC(uint32_t i)
{
		statistics[i].wcc = 0;
		std::set<uint32_t> * set = (*sets)[i];
		for(std::set<uint32_t>::iterator it = set->begin();it!=set->end();it++)
		{
			uint32_t node = *it;
			uint32_t totalTriangles = 0;
			uint32_t internalTriangles = 0;
			uint32_t totalDegreeTriangles = 0;
			uint32_t internalDegreeTriangles = 0;	
			Adjacency * adjacencies = graph->GetNeighbors(node);
			for(uint32_t j = 0; j < graph->GetDegree(node);j++)
			{
				uint32_t totalTrianglesAux;
				uint32_t internalTrianglesAux;
				uint32_t neighbor = adjacencies[j].nodeId;
				ComputeTriangles(node,neighbor,set,totalTrianglesAux,internalTrianglesAux);
				if(internalTrianglesAux!=0) internalDegreeTriangles++;
				if(totalTrianglesAux!=0) totalDegreeTriangles++;
				totalTriangles+=totalTrianglesAux;
				internalTriangles+=internalTrianglesAux;
			}


			double64_t numerador =(internalTriangles)*totalDegreeTriangles;

			double64_t denominador=totalTriangles*(totalDegreeTriangles+(set->size()-internalDegreeTriangles-1));

			if(denominador > 0)
			{
				statistics[i].wcc+=numerador/denominador;
			}

		}
		statistics[i].wcc/=set->size();
		
/*		statistics[i].wcc = 0;
		std::set<uint32_t> * set = (*sets)[i];
		for(std::set<uint32_t>::iterator it = set->begin();it!=set->end();it++)
		{
			statistics[i].wcc+= ComputeWCC2(graph,(*it),sets,nodeCommunities,alpha);
		}
		statistics[i].wcc/=set->size();
		*/
}

void ParseSets(std::ifstream& file) {
	std::list<std::set<uint32_t>*> * auxSets = new std::list<std::set<uint32_t>*>();
	std::string line;
	std::string delimiter(" ");
	while(std::getline(file,line)) {
		std::set<uint32_t>* set = new std::set<uint32_t>();
		size_t nextToken = 0;
		std::istringstream stream(line);
		uint32_t node;
		while( stream >> node ) {
			set->insert(graph->Map(node));
		}

		if(set->size()>2) {
			auxSets->push_back(set);
		}

	}

	std::list<std::set<uint32_t>*>::iterator it;
	uint32_t i = 0;
	for(it = auxSets->begin();it!=auxSets->end();++it,++i) {
		sets->push_back(*it);
	}
}

/*
void PrintGraphViz(std::set<uint32_t> * set, const char * fileName)
{
	std::ofstream outFile;
	outFile.open(fileName);
	
	outFile << "graph G {" << std::endl;
	for(std::set<uint32_t>::iterator it = set->begin(); it!=set->end();it++)
	{
		std::map<uint32_t,uint32_t>::iterator itMap = graph->mapa->find((*it));
		uint32_t i = (*itMap).second;
		uint32_t inDegree = 0;
		Adjacency * adjacencies = graph->GetNeighbors(i);
		for(uint32_t j = 0; j < graph->GetDegree(i);j++)
		{
			uint32_t neighbor = adjacencies[j].nodeId;
			if(graph->nodeCommunity[i] == graph->nodeCommunity[neighbor])
			{
				inDegree++;
			}
		}
		uint32_t color = 255-(inDegree/(double64_t)graph->nodes[i].degree)*255;
		float32_t size = (inDegree/(float32_t)set->size());
		//if(color!=0)
		{
			if(color<16)
			{
				outFile << graph->map[i] <<" [label=\"\",style=filled,color=\"#"<< std::hex << "0"<< color << "0"<< color << "0" << color <<"\"" << std::dec<< ",width="<<size <<",height="<<size << "];" << std::dec <<std::endl;	
			}
			else
			{
				outFile << graph->map[i] <<" [label=\"\",style=filled,color=\"#"<< std::hex << color << color << color <<"\"" << std::dec << ",width="<<size <<",height="<<size << "];" << std::dec <<std::endl;	
			}
			
		}
//		else
//		{ 
//			outFile << graph->map[i] <<" [label=\"\",style=filled,color=\"#000000\"];" << std::dec <<std::endl;	
//		}
		
		for(uint32_t j = 0; j < graph->nodes[i].degree;j++)
		{
			uint32_t neighbor = graph->adjacencies[graph->nodes[i].adjacencyIndex+j].nodeId;
			if(i <= neighbor)
			{
				if(graph->nodeCommunity[i] == graph->nodeCommunity[neighbor])
				{
					outFile << graph->map[i] << " -- " << graph->map[neighbor] <<" [color=red];" << std::endl;	
				}
				else
				{
//					outFile << i << " -- " << neighbor <<" [color=blue];" << std::endl;	
				}
			}
		}
	}


	outFile << "}" << std::endl;
	outFile.close();
}
*/
void ComputeSubgraph(uint32_t i)
{
	std::set<uint32_t> * set = (*sets)[i];
	subgraphs[i].size = set->size();
	subgraphs[i].adjacencies = new std::set<uint32_t>[set->size()];
	std::map<uint32_t,uint32_t> mapa;
	uint32_t k = 0;
	for(std::set<uint32_t>::iterator it = set->begin();it!=set->end();it++,k++)
	{
		mapa.insert(std::pair<uint32_t, uint32_t>(*it,k));
	}
	k = 0;	
	for(std::set<uint32_t>::iterator it = set->begin();it!=set->end();it++,k++)
	{
		uint32_t node = *it;
		uint32_t degree = graph->GetDegree(node);
		Adjacency * adjacencies = graph->GetNeighbors(node);
		for(uint32_t j = 0; j < degree;j++)
		{
			uint32_t neighbor = adjacencies[j].nodeId;
			if(set->find(neighbor) != set->end())
			{
				std::map<uint32_t,uint32_t>::iterator it2 = mapa.find(neighbor);
				if(it2==mapa.end())
				{
					std::cout << "ERROR contructing subgraph " << i << std::endl;
				}
				subgraphs[i].adjacencies[k].insert((*it2).second);
			}

		}
	}
}


uint32_t ConnectedComponents(uint32_t i,uint32_t node1,uint32_t node2)
{
	
	bool * visited = new bool[subgraphs[i].size];
	for(uint32_t j = 0; j < subgraphs[i].size;j++)
	{
		visited[j] = false;
	}
	uint32_t connectedComponents = 0;
	for(uint32_t j = 0; j < subgraphs[i].size;j++)
	{
		std::list<uint32_t> bfsList;
		if(!visited[j])
		{
			connectedComponents++;
			visited[j] = true;
			bfsList.push_back(j);
			while(!bfsList.empty())
			{
				uint32_t nextNode = bfsList.front();
				bfsList.pop_front();
				for(std::set<uint32_t>::iterator it = subgraphs[i].adjacencies[nextNode].begin();it!=subgraphs[i].adjacencies[nextNode].end();it++)
				{
					uint32_t nextNeighbor = *it;
					if(!((nextNode==node1 && nextNeighbor==node2) || (nextNode==node2 && nextNeighbor==node1)))
					{
						if(!visited[nextNeighbor])
						{
							visited[nextNeighbor] = true;
							bfsList.push_back(nextNeighbor);
						}
					}
				}
			}
		}

	}
	
	delete [] visited;
	return connectedComponents;
}

void ComputeConnectedComponents(uint32_t i)
{
	
	bool * visited = new bool[subgraphs[i].size];
	for(uint32_t j = 0; j < subgraphs[i].size;j++)
	{
		visited[j] = false;
	}
	uint32_t connectedComponents = 0;
	for(uint32_t j = 0; j < subgraphs[i].size;j++)
	{
		std::list<uint32_t> bfsList;
		if(!visited[j])
		{
			connectedComponents++;
			visited[j] = true;
			bfsList.push_back(j);
			while(!bfsList.empty())
			{
				uint32_t nextNode = bfsList.front();
				bfsList.pop_front();
				for(std::set<uint32_t>::iterator it = subgraphs[i].adjacencies[nextNode].begin();it!=subgraphs[i].adjacencies[nextNode].end();it++)
				{
					uint32_t nextNeighbor = *it;
						if(!visited[nextNeighbor])
						{
							visited[nextNeighbor] = true;
							bfsList.push_back(nextNeighbor);
						}
				}
			}
		}

	}
	
	delete [] visited;
	statistics[i].connectedComponents = connectedComponents;
}

void ComputeBridges(uint32_t i)
{
/*	statistics[i].bridges = 0;
	uint32_t numEdges = 0;
	for(uint32_t j = 0; j < subgraphs[i].size;j++)
	{
		for(std::set<uint32_t>::iterator it = subgraphs[i].adjacencies[j].begin();it!=subgraphs[i].adjacencies[j].end();it++)
		{
			if( j < *it ) {
				if(ConnectedComponents(i,j,*it)>1)
				{
					statistics[i].bridges++;
				}
			}
		}
		numEdges+=subgraphs[i].adjacencies[j].size();
	}
	statistics[i].bridgesRatio = (statistics[i].bridges*2) / (double64_t)numEdges;
	*/

/*	for(uint32_t j = 0; j < subgraphs[i].size;j++)
	{

		for(std::set<uint32_t>::iterator it = subgraphs[i].adjacencies[j].begin();
			it!=subgraphs[i].adjacencies[j].end();
			++it){
			std::cout << j << " " << *it << std::endl;

		}
}
*/


	statistics[i].bridges = 0;
	std::vector<bool> visited(subgraphs[i].size,false);
	std::list<uint32_t> dfsList;
	std::list<uint32_t> stack;
	std::list<bool> booleanStack;
	uint32_t noParent = 0xffffffff;
	uint32_t numEdges = 0;
	for(uint32_t j = 0; j < subgraphs[i].size;j++)
	{
		if( !visited[j] ) {
			uint32_t counter = 0;
			std::vector<uint32_t> labels(subgraphs[i].size);
			std::vector<uint32_t> lowestLabels(subgraphs[i].size);
			std::vector<uint32_t> parents(subgraphs[i].size,noParent);
			dfsList.push_back(j);
			while(!dfsList.empty()){
				uint32_t nextNode = dfsList.back();
				dfsList.pop_back();
				if( !visited[nextNode] ) {
					stack.push_back(nextNode);
					booleanStack.push_back(true);
					visited[nextNode] = true;
					labels[nextNode] = counter;
					lowestLabels[nextNode] = counter;
					counter++;
					for(std::set<uint32_t>::iterator it = subgraphs[i].adjacencies[nextNode].begin();
						it!=subgraphs[i].adjacencies[nextNode].end();
						++it)
					{
						dfsList.push_back(*it);
						if( !visited[*it] ){
							parents[*it] = nextNode;
						}
					}
				} else if( parents[nextNode] != 0xffffffff && nextNode != parents[parents[nextNode]]) {
					stack.push_back(nextNode);
					booleanStack.push_back(false);
				}
			}
			while(!stack.empty()) {
				uint32_t nextNode = stack.back();		
				stack.pop_back();
				bool action = booleanStack.back();
				booleanStack.pop_back();
				if( action ) {
					if( parents[nextNode] != 0xffffffff ) {
						lowestLabels[parents[nextNode]] = std::min(lowestLabels[parents[nextNode]], lowestLabels[nextNode]);
						if(lowestLabels[nextNode] > labels[parents[nextNode]]) {
							statistics[i].bridges++;
						}
					}
				} else {
					for(std::set<uint32_t>::iterator it = subgraphs[i].adjacencies[nextNode].begin();
						it!=subgraphs[i].adjacencies[nextNode].end();
						++it) {
						if( parents[nextNode] != 0xffffffff && parents[nextNode] != *it) {
							lowestLabels[nextNode] = std::min(lowestLabels[nextNode],labels[*it]);
						}
					}
				}
			}
		}
		numEdges+=subgraphs[i].adjacencies[j].size();
	}
	if( numEdges > 0) {
		statistics[i].bridgesRatio = (statistics[i].bridges*2) / (double64_t)numEdges;
	} else {
		statistics[i].bridgesRatio = 0;
	}

}

uint32_t ComputeDistance(uint32_t i,uint32_t node1)
{
	std::list<uint32_t> bfsList;

	bool * visited = new bool[subgraphs[i].size];
	uint32_t * distance = new uint32_t[subgraphs[i].size];
	for(uint32_t j = 0; j < subgraphs[i].size;j++)
	{
		visited[j] = false;
		distance[j] = 0xffffffff;
	}

	visited[node1] = true;
	distance[node1] = 0;
	bfsList.push_back(node1);
	while(!bfsList.empty())
	{
		uint32_t nextNode = bfsList.front();
		bfsList.pop_front();

		for(std::set<uint32_t>::iterator it = subgraphs[i].adjacencies[nextNode].begin();it!=subgraphs[i].adjacencies[nextNode].end();it++)
		{
			uint32_t nextNeighbor = *it;
			if(!visited[nextNeighbor])
			{
				distance[nextNeighbor] = distance[nextNode]+1;
				visited[nextNeighbor] = true;
				bfsList.push_back(nextNeighbor);
			}
		}
	}
	uint32_t maxDistance = 0;
	for(uint32_t j = 0; j < subgraphs[i].size;j++)
	{
		if(i!=j)
		{
			if(distance[j] < 0xffffffff)
				maxDistance = distance[j]>maxDistance ? distance[j] : maxDistance;
		}
	}
	delete [] distance;
	delete [] visited;
	return maxDistance;

}

void ComputeDiameter(uint32_t i)
{
	uint32_t maxDistance = 0;
	for(uint32_t k = 0; k < subgraphs[i].size; k++)
	{
		uint32_t distance = ComputeDistance(i,k);
		maxDistance = distance > maxDistance ? distance : maxDistance;
	}
	statistics[i].diameter = maxDistance;
}

/*class DiameterComparison
{
	std::vector<uint32_t>* distance;
public:
	DiameterComparison( std::vector<uint32_t>* distance)
	{this->distance = distance;}
	bool operator() (const uint32_t& a, const uint32_t& b) const
	{
		return ((*distance)[a]>(*distance)[b]);
	}
};
*/

static	uint32_t SelectMax( const std::vector<sfcd::int32_t>& distances ) {
		uint32_t size = distances.size();
		assert(size > 0);
		sfcd::int32_t max = distances[0];
		uint32_t maxNode = 0;
		for( uint32_t i = 1; i < size; ++i ) {
			if( distances[i] > max ) {
				maxNode = i;
				max = distances[i];
			}
		}
		return maxNode;
	}

void ComputeApproximateDiameter(uint32_t i)
{

/*	uint32_t maxExcentricity = 0;
	srand(time(NULL));
	uint32_t node = rand() % subgraphs[i].size;

	std::set<uint32_t>
	uint32_t k = sqrt(subgraphs[i].size);
	for( uint32_t j = 0; j < k; ++j ) {
		std::vector<bool> visited(subgraphs[i].size, false);
		std::vector<uint32_t> distance(subgraphs[i].size,0xffffffff);
		DiameterComparison diameterComparison(&distance);
		std::priority_queue<uint32_t, std::vector<uint32_t>, DiameterComparison> disancesQueue(diameterComparison);
		std::list<uint32_t> bfsList;
		bfsList.push_back(node);
		visited[node] = true;
		distance[node] = 0;
		bfsList.push_back(node);
		while(!bfsList.empty())
		{
			uint32_t nextNode = bfsList.front();
			bfsList.pop_front();
			disancesQueue.push(nextNode);
			for(std::set<uint32_t>::iterator it = subgraphs[i].adjacencies[nextNode].begin();it!=subgraphs[i].adjacencies[nextNode].end();it++)
			{
				uint32_t nextNeighbor = *it;
				if(!visited[nextNeighbor])
				{
					distance[nextNeighbor] = distance[nextNode]+1;
					visited[nextNeighbor] = true;
					bfsList.push_back(nextNeighbor);
				}
			}
		}
		uint32_t currentMaxNode = disancesQueue.top();
		uint32_t currentMaxDistance = distance[currentMaxNode];
		if(maxExcentricity < currentMaxDistance ) {
			maxExcentricity = currentMaxDistance;
			node = currentMaxNode;
		}else {
			node = rand() % subgraphs[i].size;
		}
	}
	statistics[i].diameter = maxExcentricity;
	*/


	std::vector<sfcd::int32_t>	distances(subgraphs[i].size, 0xffffffff);
	sfcd::int32_t 		maxExcentricity = 0;
	uint32_t numIterations = sqrt(subgraphs[i].size);	
	for( uint32_t k = 0; k < numIterations; k++ ) {
		std::vector<bool> visited(subgraphs[i].size, false);
		std::list<uint32_t> bfsList;
		uint32_t node;
		if( k == 0 ) { node = rand() % subgraphs[i].size; } 
		else { node = SelectMax(distances); } 
		bfsList.push_back(node);
		std::list<sfcd::int32_t> levelList;
		levelList.push_back(-1);
		while(!bfsList.empty())
		{
			uint32_t nextNode = bfsList.front();
			bfsList.pop_front();
			sfcd::int32_t level = levelList.front() + 1;
			levelList.pop_front();
			distances[nextNode] = std::min( distances[nextNode], level );
			maxExcentricity = std::max(maxExcentricity, level);
			for(std::set<uint32_t>::iterator it = subgraphs[i].adjacencies[nextNode].begin();it!=subgraphs[i].adjacencies[nextNode].end();it++) {
				uint32_t nextNeighbor = *it;
				if(!visited[nextNeighbor]) {
					visited[nextNeighbor] = true;
					bfsList.push_back(nextNeighbor);
					levelList.push_back(level);
				}
			}
		}
	}
	statistics[i].diameter = static_cast<uint32_t>(maxExcentricity);
}


void ComputeConductance(uint32_t i)
{
	uint32_t outDegree = 0;
	uint32_t totalDegree = 0;
	std::set<uint32_t> * set = (*sets)[i];
	std::set<uint32_t>::iterator it = set->begin();
	for(;it!=set->end();it++)
	{

		uint32_t node = *it;
		uint32_t degree = graph->GetDegree(node);
		Adjacency * adjacencies = graph->GetNeighbors(node);
		totalDegree += degree;
		for(uint32_t j = 0; j < degree;j++)
		{
			uint32_t neighbor = adjacencies[j].nodeId;
			if(set->find(neighbor) == set->end())
			{
				outDegree++;
			}
		}
	}

	statistics[i].conductance = 0;
	if(totalDegree>0)
	{
		statistics[i].conductance = outDegree/(double64_t)totalDegree;
	}
}

void ComputeModularity(uint32_t i)
{

	std::set<uint32_t> * set = (*sets)[i];
	std::vector<uint32_t> degrees(subgraphs[i].size);
	uint32_t numEdges = graph->GetNumEdges();
	statistics[i].modularity = 0.0f;
	uint32_t j = 0;
	sfcd::int32_t degreeSum = 0;
	for( std::set<uint32_t>::iterator it = set->begin(); it!=set->end(); ++it, ++j ) {
		degrees[j] = graph->GetDegree(*it);
		degreeSum += (sfcd::int32_t)degrees[j];
	}

	uint32_t accumDegree = 0;
	for( uint32_t k = 0; k < subgraphs[i].size; ++k ) {
		accumDegree += subgraphs[i].adjacencies[k].size();
	}

/*	for( uint32_t k = 0; k < subgraphs[i].size; ++k ) {
		for( uint32_t l = k+1; l < subgraphs[i].size; ++l ) {
			statistics[i].modularity -= 2.0f*(degrees[k]*degrees[l]/((double64_t)4.0f*numEdges*numEdges)); 
		}
	}
	statistics[i].modularity += (accumDegree / (double64_t)(2.0f*numEdges));
	*/
	for( uint32_t k = 0; k < subgraphs[i].size; ++k ) {
		statistics[i].modularity -= (degrees[k]*(degreeSum-degrees[k])/((double64_t)4.0f*numEdges*numEdges)); 
	}
	statistics[i].modularity += (accumDegree / (double64_t)(2.0f*numEdges));
	statistics[i].modularity /= subgraphs[i].size * (subgraphs[i].size - 1) ;
}

void ComputeStatistics(uint32_t i)
{

	std::set<uint32_t> * set = (*sets)[i];
	std::set<uint32_t>::iterator it = set->begin();
	statistics[i].size = set->size();
	uint32_t totalTriangles = 0, internalTriangles = 0;
	for(;it!=set->end();it++)
	{
		uint32_t node = *it;
		uint32_t internalDegree = 0;
		uint32_t degree=graph->GetDegree(node);
		Adjacency * adjacencies = graph->GetNeighbors(node);
		
		for(uint32_t j = 0; j < degree;j++)
		{
			uint32_t totalTrianglesAux;
			uint32_t internalTrianglesAux;
			uint32_t neighbor = adjacencies[j].nodeId;
			ComputeTriangles(node,neighbor,set,totalTrianglesAux,internalTrianglesAux);
			totalTriangles+=totalTrianglesAux;
			internalTriangles+=internalTrianglesAux;
			if(set->find(neighbor)!=set->end()) internalDegree++;

		}

		statistics[i].avgEdgeDensity+=(double64_t)internalDegree/((double64_t)set->size()-1);
		statistics[i].avgInverseEdgeCut+=(double64_t)internalDegree/(double64_t)degree;


	}
	statistics[i].triangleRatio = 0;
	statistics[i].triangleDensity = (double64_t)internalTriangles/(double64_t)(set->size()*(set->size()-1)*(set->size()-2));

	if(totalTriangles>0){	
		statistics[i].triangleRatio = (double64_t)internalTriangles/(double64_t)totalTriangles;
	}	
	
	statistics[i].avgEdgeDensity/=set->size();
	statistics[i].avgInverseEdgeCut/=set->size();

	timeval time;

	gettimeofday(&time, NULL);
	uint64_t initTime = (time.tv_sec * 1000) + (time.tv_usec / 1000);
	ComputeModularity(i);
	gettimeofday(&time, NULL);
	timeModularity += (time.tv_sec * 1000) + (time.tv_usec / 1000) - initTime;

	gettimeofday(&time, NULL);
	initTime = (time.tv_sec * 1000) + (time.tv_usec / 1000);
	ComputeConductance(i);
	gettimeofday(&time, NULL);
	timeConductance += (time.tv_sec * 1000) + (time.tv_usec / 1000) - initTime;

	gettimeofday(&time, NULL);
	initTime = (time.tv_sec * 1000) + (time.tv_usec / 1000);
	ComputeFlakeODF(i);
	gettimeofday(&time, NULL);
	timeFlakeODF += (time.tv_sec * 1000) + (time.tv_usec / 1000) - initTime;

	gettimeofday(&time, NULL);
	initTime = (time.tv_sec * 1000) + (time.tv_usec / 1000);
	ComputeExpansion(i);
	gettimeofday(&time, NULL);
	timeExpansion += (time.tv_sec * 1000) + (time.tv_usec / 1000) - initTime;

	gettimeofday(&time, NULL);
	initTime = (time.tv_sec * 1000) + (time.tv_usec / 1000);
	ComputeCutRatio(i);
	gettimeofday(&time, NULL);
	timeCutRatio += (time.tv_sec * 1000) + (time.tv_usec / 1000) - initTime;

	gettimeofday(&time, NULL);
	initTime = (time.tv_sec * 1000) + (time.tv_usec / 1000);
	if( subgraphs[i].size < 50 ) {
		ComputeDiameter(i);
	} else {
		ComputeApproximateDiameter(i);
	}
	gettimeofday(&time, NULL);
	timeDiameters += (time.tv_sec * 1000) + (time.tv_usec / 1000) - initTime;

	gettimeofday(&time, NULL);
	initTime = (time.tv_sec * 1000) + (time.tv_usec / 1000);
	ComputeBridges(i);
	gettimeofday(&time, NULL);
	timeBridges += (time.tv_sec * 1000) + (time.tv_usec / 1000) - initTime;

	gettimeofday(&time, NULL);
	initTime = (time.tv_sec * 1000) + (time.tv_usec / 1000);
	ComputeFOMD(i);
	gettimeofday(&time, NULL);
	timeFOMD += (time.tv_sec * 1000) + (time.tv_usec / 1000) - initTime;

	gettimeofday(&time, NULL);
	initTime = (time.tv_sec * 1000) + (time.tv_usec / 1000);
	ComputeInternalDensity(i);
	gettimeofday(&time, NULL);
	timeInternalDensity += (time.tv_sec * 1000) + (time.tv_usec / 1000) - initTime;

	gettimeofday(&time, NULL);
	initTime = (time.tv_sec * 1000) + (time.tv_usec / 1000);
	ComputeTPR(i);
	gettimeofday(&time, NULL);
	timeTPR += (time.tv_sec * 1000) + (time.tv_usec / 1000) - initTime;

	gettimeofday(&time, NULL);
	initTime = (time.tv_sec * 1000) + (time.tv_usec / 1000);
	ComputeWCC(i);
	gettimeofday(&time, NULL);
	timeWCC += (time.tv_sec * 1000) + (time.tv_usec / 1000) - initTime;
	//ComputeConnectedComponents(i);
}



int main(int argc, char ** argv)
{

	if(argc < 5){
		std::cout << "Wrong number of arguments. Usage: communityAnalizer <graphFile> <alpha> <outputFile> <partition1> <partition2> ... " << std::endl;
		exit(0);
	}

	graph = new Graph();
	uint32_t averageDegree = 0;
	if(graph->Load(argv[1])!=0)
	{
		std::cout << "ERROR: Unable to load graph" << std::endl;
	}

	alpha = atof(argv[2]);

	sets = new std::vector<std::set<uint32_t>*>();

	for(int i = 4; i < argc ; i++)
	{
		std::cout << "LOADING partition " << i-4 << std::endl;
		std::ifstream inputFile;
		inputFile.open(argv[i]);
		if(!inputFile.is_open())
		{
			std::cout << "PARTITION FILE " << i << " NOT FOUND" << std::endl;
			exit(1);
		}

		ParseSets(inputFile);
		inputFile.close();
	}


	timeModularity = 0;
	timeConductance = 0;
	timeFlakeODF = 0;
	timeExpansion = 0;
	timeCutRatio = 0;
	timeDiameters = 0;
	timeBridges = 0;
	timeFOMD = 0;
	timeInternalDensity = 0;
	timeTPR = 0;
	timeWCC = 0;


	std::vector<uint32_t> degrees;
	uint32_t minDegree = 0xffffffff;
	uint32_t maxDegree = 0;
	float32_t avgDegree = 0.0f;
	for(uint32_t i = 0; i < graph->GetNumNodes();i++)
	{
		uint32_t currentDegree = graph->GetDegree(i);
		degrees.push_back(currentDegree);
		if( currentDegree > maxDegree ) { maxDegree = currentDegree; }
		if( currentDegree < minDegree ) { minDegree = currentDegree; }
		avgDegree += currentDegree;
	}
	avgDegree /= graph->GetNumNodes();
	std::sort(degrees.begin(),degrees.end());
	median = degrees[graph->GetNumNodes()/2];


	uint32_t minCommunitySize = 0xffffffff;
	uint32_t maxCommunitySize = 0;
	float32_t avgCommunitySize = 0.0f;
	for( int i = 0; i < sets->size(); i++) {
		uint32_t currentSize = (*sets)[i]->size();
		if( currentSize > maxCommunitySize ) { maxCommunitySize = currentSize; }
		if( currentSize < minCommunitySize ) { minCommunitySize = currentSize; }
		avgCommunitySize += currentSize;
	}
	avgCommunitySize /= sets->size();

	std::ofstream outfile;
	outfile.open(argv[3]);


	uint32_t numCommunitiesWithBridges = 0;

	outfile << "WCC";
	outfile <<"\tTriangleRatio";
	outfile <<"\tTriangleDensity";
	outfile <<"\tAvgInverseEdgeCut";
	outfile <<"\tAvgEdgeDensity";
	outfile <<"\tModularity";
	outfile <<"\tConductance";
	outfile <<"\tDiameter";
	outfile <<"\tBridges";
	outfile <<"\tBridgesRatio";
	outfile <<"\tSizes";
	outfile <<"\tFlakeODF";
	outfile <<"\tExpansion";
	outfile <<"\tCutRatio";
	outfile <<"\tFOMD";
	outfile <<"\tTpr";
	outfile <<"\tInternalDensity";
	outfile <<"\tConnectedComponents";
    outfile << std::endl;

	std::cout << "NUMBER OF SETS: " << sets->size() << std::endl;


	statistics = new Statistics[sets->size()];
	subgraphs = new Subgraph[sets->size()];
	int numSets = sets->size();

	nodeNumCommunities = new uint32_t[graph->GetNumNodes()];
	nodeCommunities = new std::set<uint32_t>[graph->GetNumNodes()];
	histogramComSize = new uint32_t[graph->GetNumNodes()];
	histogramNodeCommunities = new uint32_t[graph->GetNumNodes()];
	std::list<uint32_t> sortingList;
	
	for(uint32_t i = 0; i < graph->GetNumNodes();i++)
	{
		sortingList.push_back(i);
		nodeNumCommunities[i] = 0;
		histogramComSize[i] = 0;
		histogramNodeCommunities[i] = 0;
	}

	for( int i = 0; i < numSets; i++)
	{

		if( i % 10000 == 0 ) {
			std::cout << "COMPUTING SET " << i << " out of " << numSets << std::endl;
		}
		/*Community c;
		c.i = i;
		communities.push_back(c);*/
		ComputeSubgraph(i);
		ComputeStatistics(i);
		if(statistics[i].size > 2)
		{
				outfile << statistics[i].wcc;
		        outfile	<< "	" << statistics[i].triangleRatio;
		        outfile	<< "	" << statistics[i].triangleDensity;
		        outfile	<< "	" << statistics[i].avgInverseEdgeCut;
		        outfile	<< "	" << statistics[i].avgEdgeDensity;
		        outfile	<< "	" << statistics[i].modularity;
		        outfile	<< "	" << statistics[i].conductance;
		        outfile	<< "	" << statistics[i].diameter;
		        outfile	<< "	" << statistics[i].bridges;
		        outfile	<< " 	" << statistics[i].bridgesRatio;
		        outfile	<< "	" << statistics[i].size;
		        outfile	<< "	" << statistics[i].flakeODF;
		        outfile	<< "	" << statistics[i].expansion;
		        outfile	<< "	" << statistics[i].cutRatio;
		        outfile	<< "	" << statistics[i].fomd;
		        outfile	<< "	" << statistics[i].tpr;
		        outfile	<< "	" << statistics[i].internalDensity;
		        outfile	<< "	" << statistics[i].connectedComponents;
		        outfile	<< std::endl;
		}
		
		if(statistics[i].bridgesRatio > 0.0f) numCommunitiesWithBridges++;

		histogramComSize[statistics[i].size-1]++;

		for(std::set<uint32_t>::iterator it = (*sets)[i]->begin();it!=(*sets)[i]->end();it++)
		{
			nodeNumCommunities[*it]++;
			nodeCommunities[*it].insert(i);
		}
		
	}


	for(uint32_t i = 0; i < graph->GetNumNodes();i++)
	{
		if(nodeNumCommunities[i]>0)
		{
			histogramNodeCommunities[nodeNumCommunities[i]-1]++;	
		}
	}

	std::cout << "Percentage of communities with bridges: " <<  100*numCommunitiesWithBridges/(double64_t)sets->size() << std::endl;
	std::cout <<  numCommunitiesWithBridges << " out of " << sets->size() << std::endl;

	std::ofstream histoFileSizes;
	histoFileSizes.open("histogramaMidesComunitats.txt");
	std::ofstream histoFileNodeCommunities;
	histoFileNodeCommunities.open("histogramaNodesComunitats.txt");

	for(uint32_t i = 0; i < graph->GetNumNodes(); i++)
	{
		histoFileSizes << i+1 << " " << histogramComSize[i] << std::endl;
		histoFileNodeCommunities << i+1 << " " << histogramNodeCommunities[i] << std::endl;
	}

	histoFileSizes.close();
	histoFileNodeCommunities.close();


	sortingList.sort(compare_nodes);
	std::ofstream nodeCommunitiesFile;
	nodeCommunitiesFile.open("nodeCommunities.txt");
	for(std::list<uint32_t>::iterator itNodes = sortingList.begin();itNodes!=sortingList.end();itNodes++)
	{
		nodeCommunitiesFile << graph->ReMap(*itNodes) << " ";
		for(std::set<uint32_t>::iterator it = nodeCommunities[*itNodes].begin();it!=nodeCommunities[*itNodes].end();it++)
		{
			nodeCommunitiesFile << *it << " ";
		}
		nodeCommunitiesFile << std::endl;
	}
	nodeCommunitiesFile.close();


	delete [] nodeNumCommunities;
	delete [] nodeCommunities;
	delete [] histogramComSize;
	delete [] histogramNodeCommunities;
	
	outfile.close();	

	std::cout << "Minimum Degree: " << minDegree << std::endl;
	std::cout << "Maximum Degree: " << maxDegree << std::endl;
	std::cout << "Average Degree: " << avgDegree << std::endl;
	std::cout << "Median Degree: " << median << std::endl;

	std::cout << "Minimum Community Size: " << minCommunitySize << std::endl;
	std::cout << "Maximum Community Size: " << maxCommunitySize << std::endl;
	std::cout << "Average Community Size: " << avgCommunitySize << std::endl;

	std::cout << "Time Modularity: " <<	timeModularity << " ms " << std::endl;
	std::cout << "Time Conductance: " <<	timeConductance << " ms " << std::endl;
	std::cout << "Time FlakeODF: " <<	timeFlakeODF << " ms " << std::endl;
	std::cout << "Time Expansion: " <<	timeExpansion << " ms " << std::endl;
	std::cout << "Time CutRatio: " <<	timeCutRatio << " ms " << std::endl;
	std::cout << "Time Diameters: " <<	timeDiameters << " ms " << std::endl;
	std::cout << "Time Bridges: " <<	timeBridges << " ms " << std::endl;
	std::cout << "Time FOMD: " <<	timeFOMD << " ms " << std::endl;
	std::cout << "Time InternalDensity: " <<	timeInternalDensity << " ms " << std::endl;
	std::cout << "Time TPR: " <<	timeTPR << " ms " << std::endl;

	std::cout << "Time WCC: " <<	timeWCC << " ms " << std::endl;
	return 0;
}
